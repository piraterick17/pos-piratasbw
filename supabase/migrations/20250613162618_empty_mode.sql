/*
  # Refactorización de pagos y estados de pedidos

  1. Nueva tabla de pagos
    - Registrar múltiples pagos por pedido
    - Seguimiento de métodos de pago y montos
    - Auditoría de quién cobró

  2. Mejoras a tabla de pedidos
    - Campos de auditoría para finalización
    - Eliminación de restricciones obsoletas

  3. Políticas de seguridad
    - RLS para tabla de pagos
*/

-- =================================================================
-- REFACTORIZACIÓN DE PAGOS Y ESTADOS DE PEDIDOS
-- =================================================================

-- 1. CREAR TABLA PARA REGISTRAR PAGOS
-- Cada pedido puede tener uno o más pagos asociados.
CREATE TABLE IF NOT EXISTS public.pagos (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    pedido_id BIGINT NOT NULL REFERENCES public.pedidos(id),
    metodo_pago TEXT NOT NULL,
    monto NUMERIC(10, 2) NOT NULL,
    fecha_pago TIMESTAMPTZ DEFAULT now(),
    cobrado_por_usuario_id UUID REFERENCES public.usuarios(id),
    observaciones TEXT,
    insert_date TIMESTAMPTZ DEFAULT now()
);

ALTER TABLE public.pagos ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Permitir gestión de pagos a usuarios autenticados" ON public.pagos
FOR ALL USING (auth.role() = 'authenticated');

-- 2. MEJORAR LA TABLA DE PEDIDOS
-- Añadimos las columnas que faltaban para la auditoría de cobro y finalización.
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'pedidos' AND column_name = 'cobrado_por_usuario_id') THEN
    ALTER TABLE public.pedidos ADD COLUMN cobrado_por_usuario_id UUID REFERENCES public.usuarios(id);
  END IF;
  
  IF NOT EXISTS (SELECT 1 FROM information_schema.columns WHERE table_name = 'pedidos' AND column_name = 'fecha_finalizacion') THEN
    ALTER TABLE public.pedidos ADD COLUMN fecha_finalizacion TIMESTAMPTZ;
  END IF;
END $$;

-- 3. ELIMINAR LA RESTRICCIÓN ROTA DE 'pedidos_estado_check'
-- Esta regla antigua nos está dando problemas. La eliminaremos y la manejaremos con la tabla de transiciones.
ALTER TABLE public.pedidos DROP CONSTRAINT IF EXISTS pedidos_estado_check;

-- 4. CREAR ÍNDICES PARA MEJORAR RENDIMIENTO
CREATE INDEX IF NOT EXISTS idx_pagos_pedido_id ON public.pagos(pedido_id);
CREATE INDEX IF NOT EXISTS idx_pagos_fecha ON public.pagos(fecha_pago);
CREATE INDEX IF NOT EXISTS idx_pedidos_fecha_finalizacion ON public.pedidos(fecha_finalizacion);

-- 5. FUNCIÓN PARA CALCULAR TOTAL PAGADO DE UN PEDIDO
CREATE OR REPLACE FUNCTION public.calcular_total_pagado(pedido_id_param BIGINT)
RETURNS NUMERIC(10, 2) AS $$
DECLARE
  total_pagado NUMERIC(10, 2);
BEGIN
  SELECT COALESCE(SUM(monto), 0) INTO total_pagado
  FROM public.pagos
  WHERE pedido_id = pedido_id_param;
  
  RETURN total_pagado;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 6. FUNCIÓN PARA VERIFICAR SI UN PEDIDO ESTÁ COMPLETAMENTE PAGADO
CREATE OR REPLACE FUNCTION public.pedido_completamente_pagado(pedido_id_param BIGINT)
RETURNS BOOLEAN AS $$
DECLARE
  total_pedido NUMERIC(10, 2);
  total_pagado NUMERIC(10, 2);
BEGIN
  -- Obtener el total del pedido
  SELECT total INTO total_pedido
  FROM public.pedidos
  WHERE id = pedido_id_param;
  
  -- Calcular total pagado
  total_pagado := public.calcular_total_pagado(pedido_id_param);
  
  -- Verificar si está completamente pagado (con tolerancia de 0.01 para errores de redondeo)
  RETURN total_pagado >= (total_pedido - 0.01);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;